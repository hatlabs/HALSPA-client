#!/usr/bin/env bash
#
# usage: ./run.sh command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

# First, set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

# Store the absolute path to this script (useful for recursion).
readonly SCRIPT="$PROJECT_ROOT/$(basename "$0")"

################################################################################
# Project-specific commands follow.

function install {
  mpy_image="../RPI_PICO2-20250911-v1.26.1.uf2"
  # Detect operating system
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    if [ -d /Volumes/RP2350 ]; then
      echo "Copying MicroPython (macOS)"
      cp "$mpy_image" /Volumes/RP2350
      sleep 5
      mpremote fs ls  # Test that the Pico is connected
    fi
  elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux/Raspberry Pi OS
    # Check for typical mount points on Raspberry Pi OS
    rpi_mount_point=""
    for mount_point in /media/$USER/RPI-RP2 /media/pi/RPI-RP2 /mnt/RPI-RP2; do
      if [ -d "$mount_point" ]; then
        rpi_mount_point="$mount_point"
        break
      fi
    done

    # If not mounted, try to find and mount the Pico device
    if [ -z "$rpi_mount_point" ]; then
      echo "Pico not mounted, searching for device..."

      # Look for the Pico partition (RPI vendor with RP2040/RP2350 model)
      pico_device=""
      if command -v lsblk >/dev/null 2>&1; then
        # Look for RPI vendor with RP* model, then find its first partition
        pico_base_device=$(lsblk -no NAME,VENDOR,MODEL | awk '$2=="RPI" && $3~/^RP/ {print $1}' | head -1)
        if [ -n "$pico_base_device" ]; then
          # Find the first partition of this device
          pico_device="/dev/${pico_base_device}1"
        fi
      fi

      if [ -n "$pico_device" ]; then
        echo "Found Pico device: $pico_device"
        rpi_mount_point="/mnt/RPI-RP2"

        # Create mount point if it doesn't exist
        if [ ! -d "$rpi_mount_point" ]; then
          echo "Creating mount point: $rpi_mount_point"
          sudo mkdir -p "$rpi_mount_point"
        fi

        # Mount the device
        echo "Mounting $pico_device to $rpi_mount_point"
        sudo mount "$pico_device" "$rpi_mount_point"

        # Set a flag to unmount later
        pico_was_mounted_by_script=true
      else
        echo "Pico device not found. Make sure the Pico is in bootloader mode."
      fi
    fi

    if [ -n "$rpi_mount_point" ]; then
      echo "Copying MicroPython (Raspberry Pi OS) to $rpi_mount_point"
      if [ "${pico_was_mounted_by_script:-false}" = true ]; then
        sudo cp "$mpy_image" "$rpi_mount_point"
        sudo umount "$rpi_mount_point"
        echo "Unmounted $rpi_mount_point"
      else
        sudo cp "$mpy_image" "$rpi_mount_point"
      fi
      echo "Waiting for Pico to reconnect..."
      sleep 10
      mpremote fs ls  # Test that the Pico is connected
    fi
  else
    echo "Unknown OS: $OSTYPE - skipping MicroPython firmware installation"
  fi

  mpremote mip install https://raw.githubusercontent.com/robert-hh/ads1x15/refs/heads/master/ads1x15.py
  mpremote mip install github:josverl/micropython-stubs/mip/typing.mpy
  mpremote mip install contextlib

  upload
}

function upload {
  mpremote cp -r main.py picon :
  if [ -f "../custom_calibration.py" ]; then
    echo "Uploading custom calibration..."
    mpremote cp ../custom_calibration.py :picon/calibration/custom.py
  else
    echo "No custom calibration found (using defaults)"
  fi
}

function upload_calibration {
  if [ ! -f "../custom_calibration.py" ]; then
    echo "No custom_calibration.py found."
    echo "Copy calibration_template.py to custom_calibration.py and customize it."
    exit 1
  fi
  mpremote cp ../custom_calibration.py :picon/calibration/custom.py
  echo "Custom calibration uploaded to device as picon/calibration/custom.py"
}

################################################################################
# Meta-commands and utilities follow.

function help {
  # list all "public" functions (those not beginning with an underscore)
  # defined in this file
  printf "%s <task> [args]\n\nTasks:\n" "${0}"
  compgen -A function | grep -v "^_" | cat -n

  printf "\nExtended help:\n  Each task has comments for general usage\n"
}

once_hash_array=()
function _once {
  # Run a command only once during the execution of this script, even if it's
  # called multiple times.
  #
  # Usage:
  #   _once <command> [argument ...]
  #
  # Example:
  #   _once echo "Hello"
  #   _once echo "Hello"  # won't be executed

  local command="$*"
  local hash=$(echo "$command" | shasum | cut -d' ' -f1)
  if [[ ! " ${once_hash_array[@]} " =~ " ${hash} " ]]; then
    once_hash_array+=("$hash")
    eval "$command"
  fi
}

function _env {
  echo "ðŸ—ï¸ Setting environment from .env and .env.defaults"
  # Go through the files and export all variables not already present in
  # the environment. First file has precedence!
  if [ -f .env ]; then
    _export_unset .env
  else
    # Make sure a .env file exists, otherwise docker-compose will complain
    cp .env.defaults .env
  fi
  _export_unset .env.defaults
}

function _export_unset {
  local file="$1"

  # Need to use a temp file to avoid a subshell
  local tmpfile=$(mktemp)
  grep -v '^#' $file >$tmpfile

  while read -r line; do
    if [[ ! "$line" =~ ^[[:space:]]*$ ]]; then
      varname=$(echo "$line" | cut -d= -f1)
      if [[ -z "${!varname:-}" ]]; then
        eval $line
        export $varname
      fi
    fi
  done <$tmpfile
  rm $tmpfile
}

function _test_export_unset {
  _export_unset .env
  env | sort
}


################################################################################
# Commands end.

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s
